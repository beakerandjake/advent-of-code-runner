import {
  describe, jest, test, afterEach,
} from '@jest/globals';
import { mockConfig, mockLogger } from '../mocks.js';

// setup mocks
mockLogger();
const { getConfigValue } = mockConfig();
jest.unstable_mockModule('node:fs/promises', () => ({ readFile: jest.fn() }));
jest.unstable_mockModule('fs-extra/esm', () => ({ outputFile: jest.fn() }));
jest.unstable_mockModule('src/validation/userFilesExist.js', () => ({ readmeExists: jest.fn() }));
jest.unstable_mockModule('src/statistics.js', () => ({ getPuzzleCompletionData: jest.fn() }));
jest.unstable_mockModule('src/tables/markdownProgressTable.js', () => ({ generateMarkdownProgressTable: jest.fn() }));

// import after setting up mocks
const { readFile } = await import('node:fs/promises');
const { outputFile } = await import('fs-extra/esm');
const { readmeExists } = await import('../../src/validation/userFilesExist.js');
const { getPuzzleCompletionData } = await import('../../src/statistics.js');
const {
  saveToReadme,
  saveProgressTableToReadme,
} = await import('../../src/actions/saveProgressTableToReadme.js');

describe('saveProgressTableToReadme()', () => {
  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('saveToReadme()', () => {
    test('throws if enclosing tag is missing', async () => {
      readFile.mockResolvedValue('ASDF ASDF ASDF!');
      await expect(async () => saveToReadme('ASDF')).rejects.toThrow();
    });

    test('replaces content of enclosing tag', async () => {
      const originalFileContents = '\n<!--START_AUTOGENERATED_COMPLETION_PROGRESS_SECTION-->ORIGINAL CONTENT BLAH BLAH<!--END_AUTOGENERATED_COMPLETION_PROGRESS_SECTION-->';
      readFile.mockResolvedValue(originalFileContents);
      const input = 'NEW FILE CONTENTS HA HA HA!';
      await saveToReadme(input);
      expect(outputFile).toHaveBeenCalledWith(undefined, `\n<!--START_AUTOGENERATED_COMPLETION_PROGRESS_SECTION-->\n${input}\n<!--END_AUTOGENERATED_COMPLETION_PROGRESS_SECTION-->`);
    });
  });

  describe('saveCompletionTableToReadme()', () => {
    test.each([
      null, undefined,
    ])('throws if year is: "%s"', async (year) => {
      await expect(async () => saveProgressTableToReadme({ year })).rejects.toThrow();
    });

    test('does not update readme if disabled via config', async () => {
      getConfigValue.mockImplementation((key) => {
        if (key === 'disableReadmeAutoSaveProgress') {
          return true;
        }
        throw new Error('unexpected config key');
      });
      await saveProgressTableToReadme({ year: 2022 });
      expect(outputFile).not.toHaveBeenCalled();
      expect(readmeExists).not.toHaveBeenCalled();
      expect(getPuzzleCompletionData).not.toHaveBeenCalled();
    });

    test('does not update readme if readme does not exist', async () => {
      readmeExists.mockResolvedValue(false);
      await saveProgressTableToReadme({ year: 2022 });
      expect(outputFile).not.toHaveBeenCalled();
    });

    test('does not update readme if no completion data', async () => {
      readmeExists.mockResolvedValue(true);
      getPuzzleCompletionData.mockResolvedValue([]);
      await saveProgressTableToReadme({ year: 2022 });
      expect(getPuzzleCompletionData).toHaveBeenCalled();
      expect(outputFile).not.toHaveBeenCalled();
    });
  });
});
